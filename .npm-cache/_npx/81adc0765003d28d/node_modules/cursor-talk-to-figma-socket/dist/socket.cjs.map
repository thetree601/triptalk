{"version":3,"sources":["../src/socket.ts"],"sourcesContent":["#!/usr/bin/env bun\n\nimport { Server, ServerWebSocket } from \"bun\";\n\n// Store clients by channel\nconst channels = new Map<string, Set<ServerWebSocket<any>>>();\n\nfunction handleConnection(ws: ServerWebSocket<any>) {\n  // Don't add to clients immediately - wait for channel join\n  console.log(\"New client connected\");\n\n  // Send welcome message to the new client\n  ws.send(JSON.stringify({\n    type: \"system\",\n    message: \"Please join a channel to start chatting\",\n  }));\n\n  ws.close = () => {\n    console.log(\"Client disconnected\");\n\n    // Remove client from their channel\n    channels.forEach((clients, channelName) => {\n      if (clients.has(ws)) {\n        clients.delete(ws);\n\n        // Notify other clients in same channel\n        clients.forEach((client) => {\n          if (client.readyState === WebSocket.OPEN) {\n            client.send(JSON.stringify({\n              type: \"system\",\n              message: \"A user has left the channel\",\n              channel: channelName\n            }));\n          }\n        });\n      }\n    });\n  };\n}\n\nconst server = Bun.serve({\n  port: 3055,\n  // uncomment this to allow connections in windows wsl\n  // hostname: \"0.0.0.0\",\n  fetch(req: Request, server: Server) {\n    // Handle CORS preflight\n    if (req.method === \"OPTIONS\") {\n      return new Response(null, {\n        headers: {\n          \"Access-Control-Allow-Origin\": \"*\",\n          \"Access-Control-Allow-Methods\": \"GET, POST, OPTIONS\",\n          \"Access-Control-Allow-Headers\": \"Content-Type, Authorization\",\n        },\n      });\n    }\n\n    // Handle WebSocket upgrade\n    const success = server.upgrade(req, {\n      headers: {\n        \"Access-Control-Allow-Origin\": \"*\",\n      },\n    });\n\n    if (success) {\n      return; // Upgraded to WebSocket\n    }\n\n    // Return response for non-WebSocket requests\n    return new Response(\"WebSocket server running\", {\n      headers: {\n        \"Access-Control-Allow-Origin\": \"*\",\n      },\n    });\n  },\n  websocket: {\n    open: handleConnection,\n    message(ws: ServerWebSocket<any>, message: string | Buffer) {\n      try {\n        const data = JSON.parse(message as string);\n        console.log(`\\n=== Received message from client ===`);\n        console.log(`Type: ${data.type}, Channel: ${data.channel || 'N/A'}`);\n        if (data.message?.command) {\n          console.log(`Command: ${data.message.command}, ID: ${data.id}`);\n        } else if (data.message?.result) {\n          console.log(`Response: ID: ${data.id}, Has Result: ${!!data.message.result}`);\n        }\n        console.log(`Full message:`, JSON.stringify(data, null, 2));\n\n        if (data.type === \"join\") {\n          const channelName = data.channel;\n          if (!channelName || typeof channelName !== \"string\") {\n            ws.send(JSON.stringify({\n              type: \"error\",\n              message: \"Channel name is required\"\n            }));\n            return;\n          }\n\n          // Create channel if it doesn't exist\n          if (!channels.has(channelName)) {\n            channels.set(channelName, new Set());\n          }\n\n          // Add client to channel\n          const channelClients = channels.get(channelName)!;\n          channelClients.add(ws);\n\n          console.log(`\\n✓ Client joined channel \"${channelName}\" (${channelClients.size} total clients)`);\n\n          // Notify client they joined successfully\n          ws.send(JSON.stringify({\n            type: \"system\",\n            message: `Joined channel: ${channelName}`,\n            channel: channelName\n          }));\n\n          ws.send(JSON.stringify({\n            type: \"system\",\n            message: {\n              id: data.id,\n              result: \"Connected to channel: \" + channelName,\n            },\n            channel: channelName\n          }));\n\n          // Notify other clients in channel\n          channelClients.forEach((client) => {\n            if (client !== ws && client.readyState === WebSocket.OPEN) {\n              client.send(JSON.stringify({\n                type: \"system\",\n                message: \"A new user has joined the channel\",\n                channel: channelName\n              }));\n            }\n          });\n          return;\n        }\n\n        // Handle regular messages\n        if (data.type === \"message\") {\n          const channelName = data.channel;\n          if (!channelName || typeof channelName !== \"string\") {\n            ws.send(JSON.stringify({\n              type: \"error\",\n              message: \"Channel name is required\"\n            }));\n            return;\n          }\n\n          const channelClients = channels.get(channelName);\n          if (!channelClients || !channelClients.has(ws)) {\n            ws.send(JSON.stringify({\n              type: \"error\",\n              message: \"You must join the channel first\"\n            }));\n            return;\n          }\n\n          // Broadcast to all OTHER clients in the channel (not the sender)\n          // This prevents echo and ensures proper request-response flow\n          let broadcastCount = 0;\n          channelClients.forEach((client) => {\n            if (client !== ws && client.readyState === WebSocket.OPEN) {\n              broadcastCount++;\n              const broadcastMessage = {\n                type: \"broadcast\",\n                message: data.message,\n                sender: \"peer\",\n                channel: channelName\n              };\n              console.log(`\\n=== Broadcasting to peer #${broadcastCount} ===`);\n              console.log(JSON.stringify(broadcastMessage, null, 2));\n              client.send(JSON.stringify(broadcastMessage));\n            }\n          });\n          \n          if (broadcastCount === 0) {\n            console.log(`⚠️  No other clients in channel \"${channelName}\" to receive message!`);\n          } else {\n            console.log(`✓ Broadcast to ${broadcastCount} peer(s) in channel \"${channelName}\"`);\n          }\n        }\n      } catch (err) {\n        console.error(\"Error handling message:\", err);\n      }\n    },\n    close(ws: ServerWebSocket<any>) {\n      // Remove client from their channel\n      channels.forEach((clients) => {\n        clients.delete(ws);\n      });\n    }\n  }\n});\n\nconsole.log(`WebSocket server running on port ${server.port}`);\n"],"mappings":"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","names":["server"]}